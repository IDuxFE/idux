## 类型定义

### AbstractControl

```ts
export declare abstract class AbstractControl<T = any> {
  readonly uid: number;
  /**
   * A collection of child controls.
   */
  readonly controls: ComputedRef<GroupControls<T> | AbstractControl<ArrayElement<T>>[] | undefined>;
  /**
   * The ref value for the control.
   */
  readonly valueRef: ComputedRef<T>;
  /**
   * The validation status of the control, there are three possible validation status values:
   * * **valid**: This control has passed all validation checks.
   * * **invalid**: This control has failed at least one validation check.
   * * **validating**: This control is in the midst of conducting a validation check.
   */
  readonly status: ComputedRef<ValidateStatus>;
  /**
   * An object containing any errors generated by failing validation, or undefined if there are no errors.
   */
  readonly errors: ComputedRef<ValidateErrors | undefined>;
  /**
   * A control is valid when its `status` is `valid`.
   */
  readonly valid: ComputedRef<boolean>;
  /**
   * A control is invalid when its `status` is `invalid`.
   */
  readonly invalid: ComputedRef<boolean>;
  /**
   * A control is validating when its `status` is `validating`.
   */
  readonly validating: ComputedRef<boolean>;
  /**
   * A control is validating when its `status` is `disabled`.
   */
  readonly disabled: ComputedRef<boolean>;
  /**
   * A control is marked `blurred` once the user has triggered a `blur` event on it.
   */
  readonly blurred: ComputedRef<boolean>;
  /**
   * A control is `unblurred` if the user has not yet triggered a `blur` event on it.
   */
  readonly unblurred: ComputedRef<boolean>;
  /**
   * A control is `dirty` if the user has changed the value in the UI.
   */
  readonly dirty: ComputedRef<boolean>;
  /**
   * A control is `pristine` if the user has not yet changed the value in the UI.
   */
  readonly pristine: ComputedRef<boolean>;
  /**
   * The parent control.
   */
  get parent(): AbstractControl | undefined;
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root(): AbstractControl<T>;
  /**
   * Reports the trigger validate of the `AbstractControl`.
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get trigger(): TriggerType;
  /**
   * Sets a new value for the control.
   *
   * @param value The new value.
   * @param options Configuration options that emits events when the value changes.
   * * `dirty`: Marks it dirty, default is false.
   */
  abstract setValue(value: T, options?: { dirty?: boolean }): void;
  abstract setValue(value: Partial<T>, options?: { dirty?: boolean }): void;
  /**
   * The aggregate value of the control.
   */
  abstract getValue(): T;
  /**
   * Resets the control, marking it `unblurred` `pristine`, and setting the value to initialization value.
   */
  reset(): void;
  /**
   * Running validations manually, rather than automatically.
   */
  validate(): Promise<ValidateErrors | undefined>;
  /**
   * Marks the control as `disable`.
   */
  disable(): void;
  /**
   * Enables the control,
   */
  enable(): void;
  /**
   * Marks the control as `blurred`.
   */
  markAsBlurred(): void;
  /**
   * Marks the control as `unblurred`.
   */
  markAsUnblurred(): void;
  /**
   * Marks the control as `dirty`.
   */
  markAsDirty(): void;
  /**
   * Marks the control as `pristine`.
   */
  markAsPristine(): void;
  /**
   * Sets the new sync validator for the form control, it overwrites existing sync validators.
   * If you want to clear all sync validators, you can pass in a undefined.
   */
  setValidator(newValidator?: ValidatorFn | ValidatorFn[]): void;
  /**
   * Sets the new async validator for the form control, it overwrites existing async validators.
   * If you want to clear all async validators, you can pass in a undefined.
   */
  setAsyncValidator(newAsyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | undefined): void;
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control.
   */
  get<K extends OptionalKeys<T>>(path: K): AbstractControl<T[K]> | undefined;
  get<K extends keyof T>(path: K): AbstractControl<T[K]>;
  get<TK = any>(path: ControlPathType): AbstractControl<TK> | undefined;
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   */
  setErrors(errors?: ValidateErrors): void;
  /**
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   */
  getError(errorCode: string, path?: ControlPathType): ValidateError | undefined;
  /**
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   */
  hasError(errorCode: string, path?: ControlPathType): boolean;
  /**
   * @param parent Sets the parent of the control
   */
  setParent(parent: AbstractControl): void;
  /**
   * Watch the ref value for the control.
   *
   * @param cb The callback when the value changes
   * @param options Optional options of watch
   */
  watchValue(cb: WatchCallback<T, T | undefined>, options?: WatchOptions): WatchStopHandle;
  /**
   * Watch the status for the control.
   *
   * @param cb The callback when the status changes
   * @param options Optional options of watch
   */
  watchStatus(cb: WatchCallback<ValidateStatus, ValidateStatus | undefined>, options?: WatchOptions): WatchStopHandle;
}
```

### FormGroup

```ts
export declare class FormGroup<T extends Record<string, any> = Record<string, any>> extends AbstractControl<T> {
  /**
   * A collection of child controls. The key for each child is the name under which it is registered.
   */
  readonly controls: ComputedRef<GroupControls<T>>;
  setValue(value: Partial<T>, options?: { dirty?: boolean }): void;
  getValue(): T;
  /**
   * Add a control to this form group.
   *
   * @param name The control name to add to the collection
   * @param control Provides the control for the given name
   */
  addControl<K extends OptionalKeys<T>>(name: K, control: AbstractControl<T[K]>): void;
  /**
   * Remove a control from this form group.
   *
   * @param name The control name to remove from the collection
   */
  removeControl<K extends OptionalKeys<T>>(name: K): void;
  /**
   * Replace an existing control.
   *
   * @param name The control name to replace in the collection
   * @param control Provides the control for the given name
   */
  setControl<K extends keyof T>(name: K, control: AbstractControl<T[K]>): void;
}
```

### FormArray

```ts
export declare class FormArray<T extends any[] = any[]> extends AbstractControl<T> {
  /**
   * An array of child controls. Each child control is given an index where it is registered.
   */
  readonly controls: ComputedRef<AbstractControl<ArrayElement<T>>[]>;
  /**
   * Length of the control array.
   */
  readonly length: ComputedRef<number>;
  setValue(value: Partial<ArrayElement<T>>[], options?: { dirty?: boolean }): void;
  getValue(): T;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control
   */
  at(index: number): AbstractControl<ArrayElement<T>>;
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   */
  push(control: AbstractControl<ArrayElement<T>>): void;
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control
   * @param control Form control to be inserted
   */
  insert(index: number, control: AbstractControl<ArrayElement<T>>): void;
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control
   */
  removeAt(index: number): void;
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control
   * @param control The `AbstractControl` control to replace the existing control
   */
  setControl(index: number, control: AbstractControl<ArrayElement<T>>): void;
}
```

### FormControl

```ts
export declare class FormControl<T = any> extends AbstractControl<T> {
  setValue(value: T, options?: { dirty?: boolean }): void;
  getValue(): T;
}
```
