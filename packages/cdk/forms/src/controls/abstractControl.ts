/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */

import type { ComputedRef, DeepReadonly, Ref, WatchCallback, WatchOptions, WatchStopHandle } from 'vue'
import type {
  AsyncValidatorFn,
  ErrorMessages,
  ValidationErrors,
  TriggerType,
  ValidationError,
  ValidatorFn,
  ValidatorOptions,
  ValidationStatus,
} from '../types'
import type { FormGroup } from './formGroup'
import type { FormArray } from './formArray'

import { computed, watch, readonly, ref } from 'vue'
import { hasOwnProperty, isArray, isNil, isObject } from '@idux/cdk/utils'
import { Validators } from '../validators'
import { isFormArray, isFormGroup } from '../typeof'

export abstract class AbstractControl<T = any> {
  /**
   * The ref value for the control.
   */
  readonly valueRef!: any

  /**
   * The validation status of the control, there are three possible validation status values:
   * * **valid**: This control has passed all validation checks.
   * * **invalid**: This control has failed at least one validation check.
   * * **validating**: This control is in the midst of conducting a validation check.
   */
  readonly status: DeepReadonly<Ref<ValidationStatus>>

  /**
   * An object containing any errors generated by failing validation, or null if there are no errors.
   */
  readonly errors: DeepReadonly<Ref<ValidationErrors | null>>

  /**
   * A control is valid when its `status` is `valid`.
   */
  readonly valid: ComputedRef<boolean>

  /**
   * A control is invalid when its `status` is `invalid`.
   */
  readonly invalid: ComputedRef<boolean>

  /**
   * A control is validating when its `status` is `validating`.
   */
  readonly validating: ComputedRef<boolean>

  /**
   * A control is marked `blurred` once the user has triggered a `blur` event on it.
   */
  readonly blurred: ComputedRef<boolean>

  /**
   * A control is `unblurred` if the user has not yet triggered a `blur` event on it.
   */
  readonly unblurred: ComputedRef<boolean>

  /**
   * The parent control.
   */
  get parent(): FormGroup<T> | FormArray<T[]> | null {
    return this._parent
  }

  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root(): AbstractControl<T> {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let x = this as AbstractControl<T>

    while (x.parent) {
      x = x.parent as AbstractControl<T>
    }

    return x
  }

  /**
   * Reports the trigger validate of the `AbstractControl`.
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get trigger(): TriggerType {
    return this._trigger ?? this._parent?.trigger ?? 'change'
  }

  protected _status = ref<ValidationStatus>('valid')
  protected _errors = ref<ValidationErrors | null>(null)
  protected _blurred = ref(false)

  protected _validators: ValidatorFn | null = null
  protected _asyncValidators: AsyncValidatorFn | null = null

  private _parent: FormGroup<T> | FormArray<T[]> | null = null
  private _trigger?: TriggerType

  constructor(
    validatorOrOptions?: ValidatorFn | ValidatorFn[] | ValidatorOptions | null,
    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null,
  ) {
    this.status = readonly(this._status)
    this.errors = readonly(this._errors)
    this.valid = computed(() => this.status.value === 'valid')
    this.invalid = computed(() => this.status.value === 'invalid')
    this.validating = computed(() => this.status.value === 'validating')
    this.blurred = computed(() => this._blurred.value)
    this.unblurred = computed(() => !this._blurred.value)

    this._convertOptions(validatorOrOptions, asyncValidator)
  }

  /**
   * Resets the control, marking it `unblurred`, and setting the value to initialization value.
   */
  abstract reset(): void

  /**
   * Sets a new value for the control.
   *
   * @param value The new value.
   */
  abstract setValue(value: any): void

  /**
   * The aggregate value of the control.
   */
  abstract getValue(): any

  /**
   * Marks the control as `blurred`.
   */
  abstract markAsBlurred(): void

  /**
   * Marks the control as `unblurred`.
   */
  abstract markAsUnblurred(): void

  /**
   * Running validations manually, rather than automatically.
   */
  abstract validate(): Promise<ValidationErrors | null>

  /**
   * Sets the new sync validator for the form control, it overwrites existing sync validators.
   * If you want to clear all sync validators, you can pass in a null.
   */
  setValidator(newValidator: ValidatorFn | ValidatorFn[] | null): void {
    this._validators = toValidator(newValidator)
  }

  /**
   * Sets the new async validator for the form control, it overwrites existing async validators.
   * If you want to clear all async validators, you can pass in a null.
   */
  setAsyncValidator(newAsyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null): void {
    this._asyncValidators = toAsyncValidator(newAsyncValidator)
  }

  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control.
   */
  get(path: Array<string | number> | string): AbstractControl<T> | null {
    if (isNil(path)) {
      return null
    }
    if (!isArray(path)) {
      path = path.split('.')
    }
    if (path.length === 0) {
      return null
    }

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let controlToFind: AbstractControl | null = this
    // Not using Array.reduce here due to a Chrome 80 bug
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
    path.forEach((name: string | number) => {
      if (isFormGroup(controlToFind)) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        controlToFind = hasOwnProperty(controlToFind.controls, name as string) ? controlToFind.controls[name]! : null
      } else if (isFormArray(controlToFind)) {
        controlToFind = controlToFind.at(<number>name) || null
      } else {
        controlToFind = null
      }
    })
    return controlToFind
  }

  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   */
  setErrors(errors: ValidationErrors | null): void {
    this._errors.value = errors
  }

  /**
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   */
  getError(errorCode: keyof ErrorMessages, path?: Array<string | number> | string): ValidationError | null {
    const control = path ? this.get(path) : this
    return control?.errors?.value?.[errorCode] || null
  }

  /**
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   */
  hasError(errorCode: string, path?: Array<string | number> | string): boolean {
    return !!this.getError(errorCode, path)
  }

  /**
   * @param parent Sets the parent of the control
   */
  setParent(parent: FormGroup<T> | FormArray<T[]>): void {
    this._parent = parent
  }

  /**
   * Watch the ref value for the control.
   *
   * @param cb The callback when the value changes
   * @param options Optional options of watch, the default value of `deep` is `true`
   */
  watchValue(cb: WatchCallback<T, T | undefined>, options?: WatchOptions): WatchStopHandle {
    return watch(this.valueRef, cb, { deep: true, ...options })
  }

  /**
   * Watch the status for the control.
   *
   * @param cb The callback when the status changes
   * @param options Optional options of watch
   */
  watchStatus(
    cb: WatchCallback<ValidationStatus, ValidationStatus | undefined>,
    options?: WatchOptions,
  ): WatchStopHandle {
    return watch(this.status, cb, options)
  }

  protected async _validate(): Promise<ValidationErrors | null> {
    const value = this.getValue()
    let newErrors = this._runValidator(value)
    if (isNil(newErrors)) {
      newErrors = await this._runAsyncValidator(value)
    }
    this.setErrors(newErrors)
    return newErrors
  }

  private _runValidator(value: any): ValidationErrors | null {
    return this._validators ? this._validators(value, this) : null
  }

  private _runAsyncValidator(value: any): Promise<ValidationErrors | null> {
    if (!this._asyncValidators) {
      return Promise.resolve(null)
    }
    this._status.value = 'validating'
    return this._asyncValidators(value, this)
  }

  private _convertOptions(
    validatorOrOptions: ValidatorFn | ValidatorFn[] | ValidatorOptions | null | undefined,
    asyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null | undefined,
  ) {
    if (isOptions(validatorOrOptions)) {
      this._trigger = validatorOrOptions.trigger ?? this._trigger
      this._validators = toValidator(validatorOrOptions.validators)
      this._asyncValidators = toAsyncValidator(validatorOrOptions.asyncValidators)
    } else {
      this._validators = toValidator(validatorOrOptions)
      this._asyncValidators = toAsyncValidator(asyncValidator)
    }
  }
}

function isOptions(val?: ValidatorFn | ValidatorFn[] | ValidatorOptions | null): val is ValidatorOptions {
  return isObject(val) && !isArray(val)
}

function toValidator(validator?: ValidatorFn | ValidatorFn[] | null): ValidatorFn | null {
  return isArray(validator) ? Validators.compose(validator) : validator || null
}

function toAsyncValidator(asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null): AsyncValidatorFn | null {
  return isArray(asyncValidator) ? Validators.composeAsync(asyncValidator) : asyncValidator || null
}
